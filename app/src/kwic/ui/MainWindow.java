/*
 * uiView.java
 */
package kwic.ui;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.jdesktop.application.Action;
import org.jdesktop.application.ResourceMap;
import org.jdesktop.application.SingleFrameApplication;
import org.jdesktop.application.FrameView;
import org.jdesktop.application.Task;
import org.jdesktop.application.TaskMonitor;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.PrintWriter;
import javax.swing.DefaultListModel;
import javax.swing.Timer;
import javax.swing.Icon;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.ListModel;
import javax.swing.ListSelectionModel;
import kwic.index.CircularShifter;
import kwic.index.IndexList;
import kwic.index.InputReader;
import kwic.index.IndexedString;

/**
 * The application's main frame.
 */
public class MainWindow extends FrameView {

   public MainWindow(SingleFrameApplication app) {
      super(app);

      initComponents();
      this._inputRecordList.setModel(this._inputModel);
      this._indexRecordList.setModel(this._indexModel);

      // status bar initialization - message timeout, idle icon and busy animation, etc
      ResourceMap resourceMap = getResourceMap();
      int messageTimeout = resourceMap.getInteger("StatusBar.messageTimeout");
      messageTimer = new Timer(messageTimeout, new ActionListener() {

         public void actionPerformed(ActionEvent e) {
            _statusMessageLabel.setText("");
         }
      });
      messageTimer.setRepeats(false);
      int busyAnimationRate = resourceMap.getInteger("StatusBar.busyAnimationRate");
      for (int i = 0; i < busyIcons.length; i++) {
         busyIcons[i] = resourceMap.getIcon("StatusBar.busyIcons[" + i + "]");
      }
      busyIconTimer = new Timer(busyAnimationRate, new ActionListener() {

         public void actionPerformed(ActionEvent e) {
            busyIconIndex = (busyIconIndex + 1) % busyIcons.length;
            _statusAnimationLabel.setIcon(busyIcons[busyIconIndex]);
         }
      });
      idleIcon = resourceMap.getIcon("StatusBar.idleIcon");
      _statusAnimationLabel.setIcon(idleIcon);
      _progressBar.setVisible(false);

      // connecting action tasks to status bar via TaskMonitor
      TaskMonitor taskMonitor = new TaskMonitor(getApplication().getContext());
      taskMonitor.addPropertyChangeListener(new java.beans.PropertyChangeListener() {

         public void propertyChange(java.beans.PropertyChangeEvent evt) {
            String propertyName = evt.getPropertyName();
            if ("started".equals(propertyName)) {
               if (!busyIconTimer.isRunning()) {
                  _statusAnimationLabel.setIcon(busyIcons[0]);
                  busyIconIndex = 0;
                  busyIconTimer.start();
               }
               _progressBar.setVisible(true);
               _progressBar.setIndeterminate(true);
            } else if ("done".equals(propertyName)) {
               busyIconTimer.stop();
               _statusAnimationLabel.setIcon(idleIcon);
               _progressBar.setVisible(false);
               _progressBar.setValue(0);
            } else if ("message".equals(propertyName)) {
               String text = (String) (evt.getNewValue());
               _statusMessageLabel.setText((text == null) ? "" : text);
               messageTimer.restart();
            } else if ("progress".equals(propertyName)) {
               int value = (Integer) (evt.getNewValue());
               _progressBar.setVisible(true);
               _progressBar.setIndeterminate(false);
               _progressBar.setValue(value);
            }
         }
      });
   }

   @Action
   public void showAboutBox() {
      if (aboutBox == null) {
         JFrame mainFrame = Main.getApplication().getMainFrame();
         aboutBox = new AboutBox(mainFrame);
         aboutBox.setLocationRelativeTo(mainFrame);
      }
      Main.getApplication().show(aboutBox);
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   @SuppressWarnings("unchecked")
   // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
   private void initComponents() {

      _mainPanel = new javax.swing.JPanel();
      _kwicSplitPane = new javax.swing.JSplitPane();
      _inputScrollPane = new javax.swing.JScrollPane();
      _inputRecordList = new javax.swing.JList();
      _indexScrollPane = new javax.swing.JScrollPane();
      _indexRecordList = new javax.swing.JList();
      _menu = new javax.swing.JMenuBar();
      javax.swing.JMenu _fileMenu = new javax.swing.JMenu();
      _loadMenuItem = new javax.swing.JMenuItem();
      _saveMenuItem = new javax.swing.JMenuItem();
      jSeparator1 = new javax.swing.JPopupMenu.Separator();
      javax.swing.JMenuItem _exitMenuItem = new javax.swing.JMenuItem();
      javax.swing.JMenu _helpMenu = new javax.swing.JMenu();
      javax.swing.JMenuItem _aboutMenuItem = new javax.swing.JMenuItem();
      _statusPanel = new javax.swing.JPanel();
      javax.swing.JSeparator statusPanelSeparator = new javax.swing.JSeparator();
      _statusMessageLabel = new javax.swing.JLabel();
      _statusAnimationLabel = new javax.swing.JLabel();
      _progressBar = new javax.swing.JProgressBar();
      _indexPopupMenu = new javax.swing.JPopupMenu();
      _indexRemovePopup = new javax.swing.JMenuItem();
      _inputPopupMenu = new javax.swing.JPopupMenu();
      _inputRemovePopup = new javax.swing.JMenuItem();

      _mainPanel.setMinimumSize(new java.awt.Dimension(100, 110));
      _mainPanel.setName("_mainPanel"); // NOI18N
      _mainPanel.setPreferredSize(new java.awt.Dimension(939, 500));

      _kwicSplitPane.setDividerLocation(225);
      _kwicSplitPane.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      _kwicSplitPane.setName("_kwicSplitPane"); // NOI18N

      _inputScrollPane.setName("_inputScrollPane"); // NOI18N

      _inputRecordList.setComponentPopupMenu(_inputPopupMenu);
      _inputRecordList.setName("_inputRecordList"); // NOI18N
      _inputScrollPane.setViewportView(_inputRecordList);

      _kwicSplitPane.setLeftComponent(_inputScrollPane);

      _indexScrollPane.setComponentPopupMenu(_indexPopupMenu);
      _indexScrollPane.setName("_indexScrollPane"); // NOI18N

      _indexRecordList.setComponentPopupMenu(_indexPopupMenu);
      _indexRecordList.setName("_indexRecordList"); // NOI18N
      _indexScrollPane.setViewportView(_indexRecordList);

      _kwicSplitPane.setRightComponent(_indexScrollPane);

      javax.swing.GroupLayout _mainPanelLayout = new javax.swing.GroupLayout(_mainPanel);
      _mainPanel.setLayout(_mainPanelLayout);
      _mainPanelLayout.setHorizontalGroup(
         _mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, _mainPanelLayout.createSequentialGroup()
            .addContainerGap()
            .addComponent(_kwicSplitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 915, Short.MAX_VALUE)
            .addContainerGap())
      );
      _mainPanelLayout.setVerticalGroup(
         _mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addGroup(_mainPanelLayout.createSequentialGroup()
            .addContainerGap()
            .addComponent(_kwicSplitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 487, Short.MAX_VALUE)
            .addContainerGap())
      );

      _menu.setName("_menu"); // NOI18N

      org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(kwic.ui.Main.class).getContext().getResourceMap(MainWindow.class);
      _fileMenu.setText(resourceMap.getString("_fileMenu.text")); // NOI18N
      _fileMenu.setName("_fileMenu"); // NOI18N

      javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(kwic.ui.Main.class).getContext().getActionMap(MainWindow.class, this);
      _loadMenuItem.setAction(actionMap.get("loadFile")); // NOI18N
      _loadMenuItem.setText(resourceMap.getString("_loadMenuItem.text")); // NOI18N
      _loadMenuItem.setToolTipText(resourceMap.getString("_loadMenuItem.toolTipText")); // NOI18N
      _loadMenuItem.setName("_loadMenuItem"); // NOI18N
      _fileMenu.add(_loadMenuItem);

      _saveMenuItem.setAction(actionMap.get("saveIndex")); // NOI18N
      _saveMenuItem.setText(resourceMap.getString("_saveMenuItem.text")); // NOI18N
      _saveMenuItem.setToolTipText(resourceMap.getString("_saveMenuItem.toolTipText")); // NOI18N
      _saveMenuItem.setName("_saveMenuItem"); // NOI18N
      _fileMenu.add(_saveMenuItem);

      jSeparator1.setName("jSeparator1"); // NOI18N
      _fileMenu.add(jSeparator1);

      _exitMenuItem.setAction(actionMap.get("quit")); // NOI18N
      _exitMenuItem.setName("_exitMenuItem"); // NOI18N
      _fileMenu.add(_exitMenuItem);

      _menu.add(_fileMenu);

      _helpMenu.setText(resourceMap.getString("_helpMenu.text")); // NOI18N
      _helpMenu.setName("_helpMenu"); // NOI18N

      _aboutMenuItem.setAction(actionMap.get("showAboutBox")); // NOI18N
      _aboutMenuItem.setName("_aboutMenuItem"); // NOI18N
      _helpMenu.add(_aboutMenuItem);

      _menu.add(_helpMenu);

      _statusPanel.setName("_statusPanel"); // NOI18N

      statusPanelSeparator.setName("statusPanelSeparator"); // NOI18N

      _statusMessageLabel.setName("_statusMessageLabel"); // NOI18N

      _statusAnimationLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
      _statusAnimationLabel.setName("_statusAnimationLabel"); // NOI18N

      _progressBar.setName("_progressBar"); // NOI18N

      javax.swing.GroupLayout _statusPanelLayout = new javax.swing.GroupLayout(_statusPanel);
      _statusPanel.setLayout(_statusPanelLayout);
      _statusPanelLayout.setHorizontalGroup(
         _statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addComponent(statusPanelSeparator, javax.swing.GroupLayout.DEFAULT_SIZE, 939, Short.MAX_VALUE)
         .addGroup(_statusPanelLayout.createSequentialGroup()
            .addContainerGap()
            .addComponent(_statusMessageLabel)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 755, Short.MAX_VALUE)
            .addComponent(_progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(_statusAnimationLabel)
            .addContainerGap())
      );
      _statusPanelLayout.setVerticalGroup(
         _statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addGroup(_statusPanelLayout.createSequentialGroup()
            .addComponent(statusPanelSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 2, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(_statusPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
               .addComponent(_statusMessageLabel)
               .addComponent(_statusAnimationLabel)
               .addComponent(_progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGap(3, 3, 3))
      );

      _indexPopupMenu.setName("_indexPopupMenu"); // NOI18N

      _indexRemovePopup.setAction(actionMap.get("removeIndex")); // NOI18N
      _indexRemovePopup.setText(resourceMap.getString("_indexRemovePopup.text")); // NOI18N
      _indexRemovePopup.setToolTipText(resourceMap.getString("_indexRemovePopup.toolTipText")); // NOI18N
      _indexRemovePopup.setName("_indexRemovePopup"); // NOI18N
      _indexPopupMenu.add(_indexRemovePopup);

      _inputPopupMenu.setName("_inputPopupMenu"); // NOI18N

      _inputRemovePopup.setAction(actionMap.get("removeDataAndIndex")); // NOI18N
      _inputRemovePopup.setText(resourceMap.getString("_inputRemovePopup.text")); // NOI18N
      _inputRemovePopup.setToolTipText(resourceMap.getString("_inputRemovePopup.toolTipText")); // NOI18N
      _inputRemovePopup.setName("_inputRemovePopup"); // NOI18N
      _inputPopupMenu.add(_inputRemovePopup);

      setComponent(_mainPanel);
      setMenuBar(_menu);
      setStatusBar(_statusPanel);
   }// </editor-fold>//GEN-END:initComponents

   @Action
   public Task saveIndex() {
      return new SaveIndexTask(getApplication());
   }
   //Task to save a file
   private class SaveIndexTask extends org.jdesktop.application.Task<Object, Void> {

      SaveIndexTask(org.jdesktop.application.Application app) {
         super(app);
         System.err.println("Initiating save of indexed data...");
      }

      @Override
      protected Object doInBackground() {
         System.err.println("Saving indexed data to a file...");
         //check to make sure a file has been loaded
         if(null == MainWindow.this._index) {
            return null;
         }
         try {
            //bring up the file dialog to select a file
            JFileChooser fc = new JFileChooser();
            int returnVal = fc.showSaveDialog(_mainPanel);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
               _file = fc.getSelectedFile();
               if (_file.exists()) {
                  int response = JOptionPane.showConfirmDialog(null,
                          "Overwrite existing file?",
                          "Confirm Overwrite",
                          JOptionPane.OK_CANCEL_OPTION,
                          JOptionPane.QUESTION_MESSAGE);
                  if (response == JOptionPane.CANCEL_OPTION) {
                     return null;
                  }
               }
            } else {
               return null;
            }
            this._pw = new PrintWriter(_file);
         } catch (FileNotFoundException ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
            ex.printStackTrace();
         }

         //loop over the index and write it out
         for(IndexedString sin : MainWindow.this._index) {
            String output = sin.getIndex() + "|" + sin.toString();
            //System.err.println(output);
            this._pw.println(output);
         }
         this._pw.close();
         return MainWindow.this._index;
      }

      @Override
      protected void succeeded(Object result) {
         System.err.println("Save completed successfully.");
      }

      private PrintWriter _pw = null;
      private File _file = null;
   }

   @Action
   public Task loadFile() {
      return new LoadFileTask(getApplication());
   }
   //Task to load a file
   private class LoadFileTask extends org.jdesktop.application.Task<Object, Void> {
      LoadFileTask(org.jdesktop.application.Application app) {
         super(app);

         //bring up the file dialog to select a file
         JFileChooser fc = new JFileChooser();
         int returnVal = fc.showOpenDialog(_mainPanel);

         if (returnVal == JFileChooser.APPROVE_OPTION) {
            _file = fc.getSelectedFile();
         } else {
            _file = null;
         }
      }

      @Override
      protected Object doInBackground() {
         InputReader ir = null;
         IndexedString si = null;
         //open the input file for reading
         try {
            //clear out everything to start fresh
            MainWindow.this._index = new IndexList(new CircularShifter());
            ir = new InputReader(_file.toString());
            ((DefaultListModel) MainWindow.this._inputRecordList.getModel()).clear();
            ((DefaultListModel) MainWindow.this._indexRecordList.getModel()).clear();
         } catch (FileNotFoundException ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
         }

         //read in the input, one IndexedString after the next
         do {
            try {
               si = ir.next();
            } catch (java.util.regex.PatternSyntaxException pse) {
               //FIXME could mark bad lines and then show them somewhere
               pse.printStackTrace();
               continue;
            }
            if (si == null) {
               break;
            }
            MainWindow.this._index.add(si);
            ((DefaultListModel) MainWindow.this._inputRecordList.getModel()).addElement(si);
         } while (true);

         //update the DataModel for the indexed data
         for (IndexedString sin : MainWindow.this._index) {
            System.out.println(sin.toString());
            ((DefaultListModel) MainWindow.this._indexRecordList.getModel()).addElement(sin.getIndex() + " | " + sin.toString());
         }
         try {
            ir.close();
         } catch (IOException ex) {
            Logger.getLogger(MainWindow.class.getName()).log(Level.SEVERE, null, ex);
         }

         return MainWindow.this._index;
      }

      @Override
      protected void succeeded(Object result) {
         // Runs on the EDT.  Update the GUI based on
         // the result computed by doInBackground().
      }
      private File _file;
   }

   @Action
   public Task removeDataAndIndex() {
      return new RemoveDataAndIndexTask(getApplication());
   }
   //Task to remove an index line
   private class RemoveDataAndIndexTask extends org.jdesktop.application.Task<Object, Void> {

      RemoveDataAndIndexTask(org.jdesktop.application.Application app) {
         // Runs on the EDT.  Copy GUI state that
         // doInBackground() depends on from parameters
         // to RemoveDataAndIndexTask fields, here.
         super(app);
         //copies the currently selected input lines
         selection = MainWindow.this._inputRecordList.getSelectedIndices();
      }


      @Override
      protected Object doInBackground() {
         //loop over the selections in input, and remove the shifts from the output
         DefaultListModel dlminput = ((DefaultListModel)MainWindow.this._inputRecordList.getModel());
         DefaultListModel dlmindex = ((DefaultListModel)MainWindow.this._indexRecordList.getModel());
         for(int cand = this.selection.length - 1; cand >= 0; cand--) {
            int idx = this.selection[cand];
            String input = dlminput.elementAt(idx).toString();
            IndexedString rmin = MainWindow.this._index.findInput(input.trim());
            if(rmin != null && MainWindow.this._index.containsInput(rmin)) {
               //we've identified the inputRecord, let's remove all the indexRecords
               for(int i = 0; i < MainWindow.this._index.size(); i++) {
                  String[] tokens = dlmindex.elementAt(i).toString().split(" \\| ");
                  IndexedString rmidx = MainWindow.this._index.findIndex(tokens[0].trim());
                  if(rmidx != null && rmin.getIndex().equalsIgnoreCase(rmidx.originIndex())) {
                     //if no more origin index values match rm.getOriginIndex(), remove the input line
                     MainWindow.this._index.remove(rmidx);
                     dlmindex.remove(i);
                  }
                  //force a GUI update
                  ((ListSelectionModel)MainWindow.this._indexRecordList.getSelectionModel()).clearSelection();
                  MainWindow.this._indexRecordList.updateUI();
               }

               //finally, remove the inputRecord
               MainWindow.this._index.remove(rmin);

               //find where the rmin is in the DataModel
               for(int i = 0; i < dlmindex.size(); i++) {
                  if(dlmindex.elementAt(i).toString().startsWith(rmin.getIndex())) {
                     dlmindex.remove(i);
                  }
               }
               
               //remove it from the input as well
               dlminput.remove(idx);
            }
            //force a GUI update
            ((ListSelectionModel)MainWindow.this._inputRecordList.getSelectionModel()).clearSelection();
            MainWindow.this._inputRecordList.updateUI();
         }
         return MainWindow.this._index;
      }


      @Override
      protected void succeeded(Object result) {
         // Runs on the EDT.  Update the GUI based on
         // the result computed by doInBackground().
      }
      private int[] selection;
   }

   @Action
   public Task removeIndex() {
      return new RemoveIndexTask(getApplication());
   }
   //Task to remove input lines
   private class RemoveIndexTask extends org.jdesktop.application.Task<Object, Void> {

      RemoveIndexTask(org.jdesktop.application.Application app) {
         super(app);
         selection = MainWindow.this._indexRecordList.getSelectedIndices();
      }

      /**here there be dragons. the KWIC system may have many entrys in _index so we should
      *loop over that last, but because of the iteration concurent modification problem
      *I've tried doing that loop first just to get it to work.
      *now finding that the indexes on the inputrecordlist do not match the corresponding
      *indexes on the _index, so that can't work as a way to find the parent indicies
      *will have to iterate through the entire list multiple times, not ideal
       **/
      @Override
      protected Object doInBackground() {
         DefaultListModel dlmindex = ((DefaultListModel)MainWindow.this._indexRecordList.getModel());
         for(int cand = this.selection.length - 1; cand >= 0; cand--) {
            int idx = this.selection[cand];
            //IndexedString rm = (IndexedString)cand;
            String[] tokens = dlmindex.elementAt(idx).toString().split(" \\| ");
            IndexedString rm = new IndexedString(tokens[1].trim(), tokens[0].trim());
            if(MainWindow.this._index.containsIndex(rm)) {
               //if no more origin index values match rm.getOriginIndex(), remove the input line
               MainWindow.this._index.remove(rm);
               dlmindex.remove(idx);
            }
            ((ListSelectionModel) MainWindow.this._indexRecordList.getSelectionModel()).clearSelection();
            MainWindow.this._indexRecordList.updateUI();
         }

         return null;  // return your result
      }

      @Override
      protected void succeeded(Object result) {
         // Runs on the EDT.  Update the GUI based on
         // the result computed by doInBackground().
      }
      private int[] selection;

   }
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JPopupMenu _indexPopupMenu;
   private javax.swing.JList _indexRecordList;
   private javax.swing.JMenuItem _indexRemovePopup;
   private javax.swing.JScrollPane _indexScrollPane;
   private javax.swing.JPopupMenu _inputPopupMenu;
   private javax.swing.JList _inputRecordList;
   private javax.swing.JMenuItem _inputRemovePopup;
   private javax.swing.JScrollPane _inputScrollPane;
   private javax.swing.JSplitPane _kwicSplitPane;
   private javax.swing.JMenuItem _loadMenuItem;
   private javax.swing.JPanel _mainPanel;
   private javax.swing.JMenuBar _menu;
   private javax.swing.JProgressBar _progressBar;
   private javax.swing.JMenuItem _saveMenuItem;
   private javax.swing.JLabel _statusAnimationLabel;
   private javax.swing.JLabel _statusMessageLabel;
   private javax.swing.JPanel _statusPanel;
   private javax.swing.JPopupMenu.Separator jSeparator1;
   // End of variables declaration//GEN-END:variables
   private final Timer messageTimer;
   private final Timer busyIconTimer;
   private final Icon idleIcon;
   private final Icon[] busyIcons = new Icon[15];
   private int busyIconIndex = 0;
   private JDialog aboutBox;
   private ListModel _inputModel = new DefaultListModel();
   private ListModel _indexModel = new DefaultListModel();
   private IndexList _index = null;
}
